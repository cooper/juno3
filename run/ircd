#!/usr/bin/perl
# Copyright (c) 2011, Mitchell Cooper

use warnings;
use strict;
use feature qw|switch say|;

sub VERSION () { '1.8.4' }
sub PROTO   () { '0.0.1' }

local $0     = 'juno';
our $NAME    = 'juno-ircd';
our $VERSION = '3.'.VERSION;
our $PROTO   = PROTO;
our $START   = time;
my  $NOFORK  = 'NOFORK' ~~ @ARGV;

# signals
$SIG{TERM} = \&terminate;
$SIG{KILL} = \&terminate;
$SIG{HUP}  = \&signalhup;

our $run_dir;

use POSIX;
use IO::Select;
# use POE::Component::Server::IRC; 
# LO!L!O!LO!L!OL!O!L!OL!O!LO!LO!L!
# just kidding. :)

# find the running directory.

BEGIN {

    if ($#ARGV < 0) {
        die "No directory specified.\n"
    }

    $run_dir = shift @ARGV;
    # make sure the run directory exists.
    if (!-d $run_dir) {
        die "Run directory does not exist.\n"
    }

    chdir $run_dir or die "Can't access run directory.\n";
    unshift @INC, "$run_dir/inc";

}

use POSIX;
use connection;
use server;
use user;
use channel;
use utils qw[conf lconf log2 fatal];

my  (%listen, %inbuffer, %outbuffer, %timer, %loop, @sel, $PID);
our ($select, $socket_class);
my  $loopid = 0;

log2('this is juno-ircd version 3.'.VERSION);
start();

if (!$NOFORK) {
    log2('Becoming a daemon...');

    # since there will be no input or output from here on,
    # open the filehandles to /dev/null
    open STDIN,  '<', '/dev/null' or fatal("Can't read /dev/null: $!");
    open STDOUT, '>', '/dev/null' or fatal("Can't write /dev/null: $!");
    open STDERR, '>', '/dev/null' or fatal("Can't write /dev/null: $!");

    # write the PID file that is used by the start/stop/rehash script.
    open my $pidfh, '>', "$run_dir/etc/juno.pid" or fatal("Can't write $run_dir/etc/juno.pid");
    $PID = fork;
    say $pidfh $PID if $PID;
    close $pidfh
}

exit if $PID;
POSIX::setsid();

# main loop

mainloop: while (1) {

    # read incoming data
    INCOMING: foreach my $socket ($select->can_read(1)) {
        # new request
        if ($listen{$socket}) {
            connection->new($socket->accept);
            next INCOMING;
        }

        # incoming data from an existing connection
        else {
            my $connection = connection::lookup_by_handle($socket);

            # attempt to read the data
            if ($socket->sysread(my $data, POSIX::BUFSIZ)) {
                $connection->handle($_) foreach split /\n/, $data;
            }

            # couldn't read
            else {
                $connection->done('Connection closed');
                next INCOMING;
            }

        }
    }

    # send outgoing data
    OUTGOING: foreach my $socket ($select->can_write(0)) {
        while (my $data = shift @{$outbuffer{$socket}}) {
            if (!$socket->syswrite("$data\r\n", POSIX::BUFSIZ)) {
                connection::lookup_by_handle($socket)->done('Write error');
                next OUTGOING;
            }
        }
    }

    # run through the registered loops
    $loop{$_}{code}($_) foreach keys %loop;

}

sub start {

    log2('Started at '.localtime $START);

    # parse the configuration, load the required modules, and listen

    utils::parse_config('etc/ircd.conf') or die "Can't parse configuration.\n";

    # create the main server object
    $utils::GV{server} = server->new({
        sid    => $utils::GV{serverid},
        name   => $utils::GV{servername},
        desc   => $utils::GV{serverdesc},
        proto  => 0.1,
        ircd   => $VERSION,
        time   => time,
        source => $utils::GV{serverid},
        parent => { name => 'self' }
    });

    # how is this possible?!?!
    $utils::GV{server}{parent} = $utils::GV{server};

    # register modes
    $utils::GV{server}->user::modes::add_internal_modes();
    $utils::GV{server}->channel::modes::add_internal_modes();

    load_requirements();
    create_sockets();
    fatal('Not listening') if $#sel < 0;

    $select = new IO::Select @sel;

    log2("server initialization complete");

    # auto server connect
    while (my ($name, $serv) = each %{$utils::conf{connect}}) {
        if ($serv->{autoconnect}) {
            log2("autoconnecting to $name...");
            server::linkage::connect_server($name)
        }
    }

}

sub load_requirements {

    if (defined( my $pkg = conf qw[class normal_package] )) {
        log2('Loading '.$pkg);
        $pkg =~ s/::/\//g;
        require "$pkg.pm"
    }

    if (defined( my $class = conf qw[class normal_class] )) {
        $socket_class = $class
    }

    if (conf qw[enabled sha]) {
        log2('Loading Digest::SHA');
        require Digest::SHA
    }

    if (conf qw[enabled md5]) {
        log2('Loading Digest::MD5');
        require Digest::SHA
    }

    if (conf qw[enabled resolve]) {
        log2('Loading res, Net::IP, Net::DNS');
        require res
    }

}

sub create_sockets {

    while (my ($addr, $bl) = each %{$utils::conf{listen}}) {

        foreach my $port (@{$bl->{port}}) {

            # create the socket and add it to the IO::Select object

            my $socket = $socket_class->new(
                LocalAddr => $addr,
                LocalPort => $port,
                Listen    => 1,
                ReuseAddr => 1,
                Proto     => 'tcp'
            ) or fatal("Couldn't listen on [$addr]:$port: $!");

            log2("Listening on [$addr]:$port");
            $listen{$socket} = [$addr, $port];
            push @sel, $socket

        }

    }

    return 1

}

# add data to the outgoing buffer

sub sendpeer {
    my $peer = shift;
    push @{$outbuffer{$peer}}, @_
}

# register a block of code to the main loop
sub register_loop {
    my ($name, $code) = @_;
    if (ref $code ne 'CODE') {
        log2("attempted to register a loop that is not CODE");
        return
    }
    my $id = ++$loopid;
    $loop{$id} = {
        code => $code,
        name => $name
    };
    log2("registered loop $id: $name");
    return 1
}

# delete an existing loop
sub delete_loop {
    my $id = shift;
    if (exists $loop{$id}) {
        log2("deleted loop $id ($loop{$id}{name})");
        delete $loop{$id};
        return 1
    }
    log2("attempted to delete loop $id which does not exist");
    return
}

# stop the ircd
sub terminate {

    log2("removing all connections for server shutdown");

    # delete all users/servers/other
    foreach my $connection (values %connection::connection) {
        $connection->done('shutting down');
    }

    log2("deleting PID file");

    # delete the PID file
    unlink 'etc/juno.pid' or fatal("Can't remove PID file");

    log2("shutting down");
    exit
}

# handle a HUP
sub signalhup {

    # find out what is wanted
    open my $hup, 'etc/HUP' or log2('can\'t open HUP file') and return;

    while (my $line = <$hup>) {
        my @s = split /\s+/, $line;
        given ($s[0]) {
            when ('rehash') {
                log2("reloading server configuration file by request of HUP signal");
                utils::parse_config('etc/ircd.conf') or log2("configuration error");
                log2("finished rehashing");              
            }
            when ('terminate') {
                log2("terminating by request of HUP signal");
                terminate();
            }
            deafult { return }
        }
    }

    return 1
}
