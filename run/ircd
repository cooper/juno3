#!/usr/bin/perl
# Copyright (c) 2011, Mitchell Cooper

use warnings;
use strict;
use feature 'say';

sub VERSION () { '1.6.1' }
sub PROTO   () { '0.0.1' }

local $0     = 'juno3';
our $VERSION = 'juno-3.'.VERSION;
our $PROTO   = PROTO;
our $START   = time;
my  $NOFORK  = 'NOFORK' ~~ @ARGV;

our $run_dir;

use POSIX;
use IO::Select;
# use POE::Component::Server::IRC; 
# LO!L!O!LO!L!OL!O!L!OL!O!LO!LO!L!
# just kidding. :)

# find the running directory.

BEGIN {

    if ($#ARGV < 0) {
        die "No directory specified.\n"
    }

    $run_dir = shift @ARGV;
    # make sure the run directory exists.
    if (!-d $run_dir) {
        die "Run directory does not exist.\n"
    }

    chdir $run_dir or die "Can't access run directory.\n";
    unshift @INC, "$run_dir/inc";

}

use POSIX;
use connection;
use server;
use user;
use channel;
use utils qw[conf lconf log2 fatal];

my  (%listen, %inbuffer, %outbuffer, %timer, %loop, @sel, $PID);
our ($select, $socket_class);
my  $loopid = 0;

start();

if (!$NOFORK) {
    log2('Becoming a daemon...');

    # since there will be no input or output from here on,
    # open the filehandles to /dev/null
    open STDIN,  '<', '/dev/null' or fatal("Can't read /dev/null: $!");
    open STDOUT, '>', '/dev/null' or fatal("Can't write /dev/null: $!");
    open STDERR, '>', '/dev/null' or fatal("Can't write /dev/null: $!");

    # write the PID file that is used by the start/stop/rehash script.
    open my $pidfh, '>', "$run_dir/etc/juno3.pid" or fatal("Can't write $run_dir/etc/juno3.pid");
    $PID = fork;
    say $pidfh $PID if $PID;
    close $pidfh

}

exit if $PID;
POSIX::setsid();

# main loop

mainloop: for (;;) {

    # incoming

    in: foreach my $socket ($select->can_read(1)) {

        my ($time, $conn) = time;
        $timer{$socket} = 0 unless $timer{$socket};

        # new connection

        if (exists $listen{$socket}) {
            connection->new($socket->accept);
            next in
        }

        # incoming data

        else {

            $timer{$socket} = $time if $timer{$socket} < $time;
            $conn = $connection::connection{$socket};

            if ($socket->sysread(my $data, POSIX::BUFSIZ)) {
                $inbuffer{$socket} .= $data
            }

            # can't read the data

            else {
                $conn->done('Connection closed', 1);
                next in
            }

        }

        # flood check

        my ($theline, $therest);

        while ( ($timer{$socket}-(conf qw[flood lines]) <= $time ) &&
          ( ($theline, $therest) = $inbuffer{$socket} =~ m/([^\n]*)\n(.*)/s) ) {

            $inbuffer{$socket} = $therest;
            $theline =~ s/\r$//;

            # they're okay, so handle the data

            $conn->handle($theline);
            $timer{$socket}++

        }

        # they've reached their limit; force them to quit
        if (length $inbuffer{$socket} > conf qw[flood bytes]) {
            if (!exists $conn->{type} || !$conn->{type}->isa('server')) {
                $conn->done(conf qw[flood message], 1)
            }
        }

    }

    out: foreach my $socket ($select->can_write(0)) {

        # nothing to write
        next out unless exists $outbuffer{$socket};

        # send the data
        my $sent = $socket->syswrite($outbuffer{$socket}, POSIX::BUFSIZ);

        if (defined $sent &&
          $sent <= length $outbuffer{$socket}
          || $! == POSIX::EWOULDBLOCK) {

            (substr $outbuffer{$socket}, 0, $sent) = '';
            delete $outbuffer{$socket} unless length $outbuffer{$socket}

        }

        # can't write to this socket, so give up and force the user to quit

        else {
            $connection::connection{$socket}->done('Write error')
        }

    }

    # check for pending pings, ping timeouts, and registration timeouts

    ping: foreach my $conn (values %connection::connection) {

        my ($freq, $msg, $timeout); # what is the frequency/timeout/msg?
        if (!exists $conn->{type} || $conn->{type}->isa('user')) {
            $freq    = lconf qw/ping user frequency/;
            $timeout = lconf qw/ping user timeout/;
            $msg     = lconf qw/ping user message/
        }
        elsif ($conn->{type}->isa('server')) {
            $freq    = lconf qw/ping server frequency/;
            $timeout = lconf qw/ping server timeout/;
            $msg     = 'Ping timeout'
        }

        if ((time - $conn->{last_response}) >= $timeout) {

            # too late; making them quit
            $conn->done($msg);
            next ping

        }

        if ((time-$conn->{last_response}) > $freq) {

            # send a PING command and reset the ping time
            $conn->send("PING :$utils::GV{servername}") unless $conn->{ping_in_air};
            $conn->{last_ping}   = time;
            $conn->{ping_in_air} = 1;

            # make sure that they aren't just sitting there without registering...
            $conn->done('Registration timeout') unless $conn->{type}

        }

    }

    # run through the registered loops
    loop: while (my @loop = each %loop) {
        $loop[1]->{code}($loop[0])
    }

}

sub start {

    log2('Started at '.localtime time);

    # parse the configuration, load the required modules, and listen

    utils::parse_config('etc/ircd.conf') or die "Can't parse configuration.\n";

    # create the main server object
    $utils::GV{server} = server->new({
        sid    => $utils::GV{serverid},
        name   => $utils::GV{servername},
        desc   => $utils::GV{serverdesc},
        proto  => 0.1,
        ircd   => $VERSION,
        time   => time,
        source => $utils::GV{serverid},
        parent => { name => 'self' }
    });

    # how is this possible?!?!
    $utils::GV{server}{parent} = $utils::GV{server};

    # register modes
    $utils::GV{server}->user::modes::add_internal_modes();
    $utils::GV{server}->channel::modes::add_internal_modes();

    load_requirements();
    create_sockets();
    fatal('Not listening') if $#sel < 0;

    $select = new IO::Select @sel;

    log2("server initialization complete");

    # auto server connect
    while (my ($name, $serv) = each %{$utils::conf{connect}}) {
        if ($serv->{autoconnect}) {
            log2("autoconnecting to $name...");
            server::linkage::connect_server($name)
        }
    }

}

sub load_requirements {

    if (defined( my $pkg = conf qw[class normal_package] )) {
        log2('Loading '.$pkg);
        $pkg =~ s/::/\//g;
        require "$pkg.pm"
    }

    if (defined( my $class = conf qw[class normal_class] )) {
        $socket_class = $class
    }

    if (conf qw[enabled sha]) {
        log2('Loading Digest::SHA');
        require Digest::SHA
    }

    if (conf qw[enabled md5]) {
        log2('Loading Digest::MD5');
        require Digest::SHA
    }

    if (conf qw[enabled resolve]) {
        log2('Loading res, Net::IP, Net::DNS');
        require res
    }

}

sub create_sockets {

    while (my ($addr, $bl) = each %{$utils::conf{listen}}) {

        foreach my $port (@{$bl->{port}}) {

            # create the socket and add it to the IO::Select object

            my $socket = $socket_class->new(
                LocalAddr => $addr,
                LocalPort => $port,
                Listen    => 1,
                ReuseAddr => 1,
                Proto     => 'tcp'
            ) or fatal("Couldn't listen on [$addr]:$port: $!");

            log2("Listening on [$addr]:$port");
            $listen{$socket} = [$addr, $port];
            push @sel, $socket

        }

    }

    return 1

}

# add data to the outgoing buffer

sub sendpeer {
    my $peer = shift;
    $outbuffer{$peer} .= "$_\r\n" foreach @_
}

# register a block of code to the main loop
sub register_loop {
    my ($name, $code) = @_;
    if (ref $code ne 'CODE') {
        log2("attempted to register a loop that is not CODE");
        return
    }
    my $id = ++$loopid;
    $loop{$id} = {
        code => $code,
        name => $name
    };
    log2("registered loop $id: $name");
    return 1
}

# delete an existing loop
sub delete_loop {
    my $id = shift;
    if (exists $loop{$id}) {
        log2("deleted loop $id ($loop{$id}{name})");
        delete $loop{$id};
        return 1
    }
    log2("attempted to delete loop $id which does not exist");
    return
}
