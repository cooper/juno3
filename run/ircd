#!/usr/bin/perl
# Copyright (c) 2011, Mitchell Cooper

use warnings;
use strict;
use feature 'say';

our $run_dir = '.';
our $VERSION = '0.4.2';
our $PROTO   = '0.0.1';

use POSIX;
use IO::Select;

# find the running directory.

BEGIN {

    if ($#ARGV < 0) {
        die "No directory specified.\n"
    }

    $run_dir = shift @ARGV;

    # make sure the run directory exists.
    if (!-d $run_dir) {
        die "Run directory does not exist.\n"
    }

    chdir $run_dir or die "Can't access run directory.\n";
    unshift @INC, "$run_dir/inc"

}

use POSIX;
use connection;
use user;
use server;
use user::numerics;
use user::mine;
use user::handlers;
use server::mine;
use server::linkage;
use server::handlers;
use server::outgoing;
use utils qw[conf lconf log2 fatal];

my  (%listen, %inbuffer, %outbuffer, %timer, %loop, @sel);
our ($select, $socket_class);
my  $loopid = 0;

start();

# main loop

mainloop: for (;;) {

    # incoming

    in: foreach my $socket ($select->can_read(1)) {

        my ($time, $conn) = time;
        $timer{$socket} = 0 unless $timer{$socket};

        # new connection

        if (exists $listen{$socket}) {
            connection->new($socket->accept);
            next in
        }

        # incoming data

        else {

            $timer{$socket} = $time if $timer{$socket} < $time;
            $conn = $connection::connection{$socket};

            if (sysread $socket, my $data, POSIX::BUFSIZ, 0) {
                $inbuffer{$socket} .= $data
            }

            # can't read the data

            else {
                $conn->done('Connection closed');
                next in
            }

        }

        # flood check

        my ($theline, $therest);

        while ( ($timer{$socket}-(conf qw[flood lines]) <= $time ) &&
          ( ($theline, $therest) = $inbuffer{$socket} =~ m/([^\n]*)\n(.*)/s) ) {

            $inbuffer{$socket} = $therest;
            $theline =~ s/\r$//;

            # they're okay, so handle the data

            $conn->handle($theline);
            $timer{$socket}++

        }

        # they've reached their limit; force them to quit

        $connection::connection{$socket}->done(conf qw[flood message])
        if length $inbuffer{$socket} > conf qw[flood bytes];

    }

    out: foreach my $socket ($select->can_write(0)) {

        # nothing to write
        next out unless exists $outbuffer{$socket};

        # send the data
        my $sent = syswrite $socket, $outbuffer{$socket}, POSIX::BUFSIZ;

        if (defined $sent &&
          $sent <= length $outbuffer{$socket}
          || $! == POSIX::EWOULDBLOCK) {

            (substr $outbuffer{$socket}, 0, $sent) = '';
            delete $outbuffer{$socket} unless length $outbuffer{$socket}

        }

        # can't write to this socket, so give up and force the user to quit

        else {
            $connection::connection{$socket}->done('Write error')
        }

    }

    # check for pending pings, ping timeouts, and registration timeouts

    ping: foreach my $conn (values %connection::connection) {

        my ($freq, $msg, $timeout); # what is the frequency/timeout/msg?
        if (!exists $conn->{type} || $conn->{type}->isa('user')) {
            $freq    = lconf qw/ping user frequency/;
            $timeout = lconf qw/ping user timeout/;
            $msg     = lconf qw/ping user message/
        }
        elsif ($conn->{type}->isa('server')) {
            $freq    = lconf qw/ping server frequency/;
            $timeout = lconf qw/ping server timeout/;
            $msg     = 'Ping timeout'
        }

        if ((time-$conn->{last_response}) >= $timeout) {

            # too late; making them quit
            $conn->done($msg);
            next ping

        }

        if ((time-$conn->{last_ping}) > $freq) {

            # send a PING command and reset the ping time
            $conn->send("PING :$utils::GV{servername}") unless $conn->{ping_in_air};
            $conn->{last_ping}   = time;
            $conn->{ping_in_air} = 1;

            # make sure that they aren't just sitting there without registering...
            $conn->done('Registration timeout') unless $conn->{type}

        }

    }

    # run through the registered loop
    loop: while (my @loop = each %loop) {
        $loop[1]->{code}($loop[0])
    }

}

sub start {

    log2('Started at '.localtime time);

    # parse the configuration, load the required modules, and listen

    utils::parse_config('etc/ircd.conf') or die "Can't parse configuration.\n";

    # create the main server object
    $utils::GV{server} = server->new({
        sid    => $utils::GV{serverid},
        name   => $utils::GV{servername},
        desc   => $utils::GV{serverdesc},
        proto  => 0.1,
        ircd   => $VERSION,
        time   => time,
        source => $utils::GV{serverid},
        parent => {name => 'self'}
    });

    # how is this possible?!?!
    $utils::GV{server}{parent} = $utils::GV{server};

    load_requirements();
    create_sockets();
    fatal('Not listening') if $#sel < 0;

    $select = new IO::Select @sel;

    # auto server connect
    while (my ($name, $serv) = each %{$utils::conf{connect}}) {
        server::linkage::connect_server($name) if $serv->{autoconnect}
    }

}

sub load_requirements {

    if (defined( my $pkg = conf qw[class normal_package] )) {
        log2('Loading '.$pkg);
        $pkg =~ s/::/\//g;
        require "$pkg.pm"
    }

    if (defined( my $class = conf qw[class normal_class] )) {
        $socket_class = $class
    }

    if (conf qw[enabled sha]) {
        log2('Loading Digest::SHA');
        require Digest::SHA
    }

    if (conf qw[enabled md5]) {
        log2('Loading Digest::MD5');
        require Digest::SHA
    }

    if (conf qw[enabled resolve]) {
        log2('Loading Net::DNS');
        require Net::DNS
    }

}

sub create_sockets {

    while (my ($addr, $bl) = each %{$utils::conf{listen}}) {

        foreach my $port (@{$bl->{port}}) {

            # create the socket and add it to the IO::Select object

            my $socket = $socket_class->new(
                LocalAddr => $addr,
                LocalPort => $port,
                Listen    => 1,
                ReuseAddr => 1,
                Proto     => 'tcp'
            ) or fatal("Couldn't listen on [$addr]:$port: $!");

            log2("Listening on [$addr]:$port");
            $listen{$socket} = [$addr, $port];
            push @sel, $socket

        }

    }

    return 1

}

# add data to the outgoing buffer

sub sendpeer {
    my $peer = shift;
    $outbuffer{$peer} .= "$_\r\n" foreach @_
}

# register a block of code to the main loop
sub register_loop {
    my ($name, $code) = @_;
    if (ref $code ne 'CODE') {
        log2("attempted to register a loop that is not CODE");
        return
    }
    my $id = ++$loopid;
    $loop{$id} = {
        code => $code,
        name => $name
    };
    log2("registered loop $id: $name");
    return 1
}

# delete an existing loop
sub delete_loop {
    my $id = shift;
    if (exists $loop{$id}) {
        log2("deleted loop $id ($loop{$id}{name})");
        delete $loop{$id};
        return 1
    }
    log2("attempted to delete loop $id which does not exist");
    return
}
