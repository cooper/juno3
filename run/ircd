#!/usr/bin/perl
# Copyright (c) 2011, Mitchell Cooper

use warnings;
use strict;
use feature qw|switch say|;

local ($0,     $SIG{TERM},   $SIG{KILL}, $SIG{HUP},   $SIG{__WARN__}) =
      ('juno', \&terminate, \&terminate, \&signalhup, \&WARNING     );

# temporary vars
my (%global, @sel);
our $run_dir;
BEGIN {

    # find the directory to run from

    if ($#ARGV < 0) {
        die "No directory specified.\n"
    }

    $run_dir = shift @ARGV;
    # make sure the run directory exists.
    if (!-d $run_dir) {
        die "Run directory does not exist.\n"
    }

    chdir $run_dir or die "Can't access run directory.\n";
    unshift @INC, "$run_dir/inc", "$run_dir/dep";

    # set global variables
    # that will eventually be moved to GV after startup

    %global = (
        NAME    => 'juno-ircd',
        VERSION => '3.1.9.2',
        PROTO   => '0.0.1',
        START   => time,
        NOFORK  => 'NOFORK' ~~ @ARGV
    );

}

use POSIX;
use IO::Select;
use IO::Socket::IP;
# allowing to use any ::INET-like module was becoming confusing
# in the configuration, so IO::Socket::IP is now a dependency
# to make things simple.

use connection;
use server;
use user;
use channel;
use utils qw[conf lconf log2 fatal gv set];

our $select;

log2("this is $global{NAME} version $global{VERSION}");
%utils::GV = %global;
undef %global;
start();

if (!gv('NOFORK')) {
    log2('Becoming a daemon...');

    # since there will be no input or output from here on,
    # open the filehandles to /dev/null
    open STDIN,  '<', '/dev/null' or fatal("Can't read /dev/null: $!");
    open STDOUT, '>', '/dev/null' or fatal("Can't write /dev/null: $!");
    open STDERR, '>', '/dev/null' or fatal("Can't write /dev/null: $!");

    # write the PID file that is used by the start/stop/rehash script.
    open my $pidfh, '>', "$run_dir/etc/juno.pid" or fatal("Can't write $run_dir/etc/juno.pid");
    $utils::GV{PID} = fork;
    say $pidfh gv('PID') if gv('PID');
    close $pidfh
}

exit if gv('PID');
POSIX::setsid();

# main loop

MAIN: for (;;) {

    # read incoming data
    INCOMING: foreach my $socket ($select->can_read(1)) {
        my $connection;

        # new request
        if (${*$socket}{listen}) {
            my $new = $socket->accept;
            $new->autoflush(0);
            $connection = connection->new($new);
            next INCOMING;
        }

        # incoming data from an existing connection
        else {
            $connection = connection::lookup_by_handle($socket);

            # attempt to read the data
            if ($socket->sysread(my $data, POSIX::BUFSIZ)) {
                ${*$socket}{inbuffer}  = q() unless defined ${*$socket}{inbuffer};
                ${*$socket}{inbuffer} .= $data;
            }

            # couldn't read
            else {
                $connection->done('Connection closed', 1);
                next INCOMING;
            }
        }

        next unless length ${*$socket}{inbuffer};

        # actually handle data that is ready to be handled
        while (my ($line, $remainder) = ${*$socket}{inbuffer} =~ m/([^\n]*)\n(.*)/s) {
            ${*$socket}{inbuffer} = $remainder;
            $connection->handle($_) foreach split /\n/, $line
        }
    }

    # send outgoing data
    OUTGOING: foreach my $socket ($select->can_write(0)) {
        while (my $data = shift @{${*$socket}{outbuffer}}) {
            if (!$socket->syswrite("$data\r\n")) {
                connection::lookup_by_handle($socket)->done('Write error', 1);
                next OUTGOING;
            }
        }
    }

    # ping system
    PING: foreach my $connection (values %connection::connection) {
        my ($freq, $msg, $timeout);

        # user limits and unknown connections
        if (!exists $connection->{type} || $connection->{type}->isa('user')) {
            $freq    = lconf qw/ping user frequency/;
            $timeout = lconf qw/ping user timeout/;
            $msg     = lconf qw/ping user message/
        }

        # server limits
        elsif ($connection->{type}->isa('server')) {
            $freq    = lconf qw/ping server frequency/;
            $timeout = lconf qw/ping server timeout/;
            $msg     = 'Ping timeout'
        }

        # too late; make him quit
        if ((time - $connection->{last_response}) >= $timeout) {
            $connection->done($msg);
            next PING;
        }

        if ((time - $connection->{last_response}) > $freq) {

            # make sure that they aren't just sitting there without registering...
            $connection->done('Registration timeout') unless $connection->{type};
            next PING;

            # send a PING command and reset the ping time
            $connection->send("PING :".gv('SERVER', 'name')) unless $connection->{ping_in_air};
            $connection->{last_ping}   = time;
            $connection->{ping_in_air} = 1;

        }
    }

    # run through the registered loops
    foreach (keys %{$utils::GV{LOOP}}) {
        next if $_ eq 'ID';
        $utils::GV{LOOP}{$_}{code}($_)
    }

}

sub start {

    log2('Started server at '.localtime gv('START'));

    # parse the configuration, load the required modules, and listen

    utils::parse_config('etc/ircd.conf') or die "Can't parse configuration.\n";

    # create the main server object
    my $server = server->new({
        source => conf('server', 'id'),
        sid    => conf('server', 'id'),
        name   => conf('server', 'name'),
        desc   => conf('server', 'description'),
        proto  => gv('PROTO'),
        ircd   => gv('VERSION'),
        time   => gv('START'),
        parent => { name => 'self' }
    });

    # how is this possible?!?!
    $server->{parent} = $server;

    # set this as the G server
    $utils::GV{SERVER} = $server;

    # register modes
    $server->user::modes::add_internal_modes();
    $server->channel::modes::add_internal_modes();

    load_requirements();

    # listen and add sockets to IO::Select object
    create_sockets();
    fatal('Not listening') if $#sel < 0;
    $select = IO::Select->new(@sel);

    log2("server initialization complete");

    # auto server connect
    foreach my $name (keys %{$utils::conf{connect}}) {
        my $serv = $utils::conf{connect}{$name};
        if ($serv->{autoconnect}) {
            log2("autoconnecting to $name...");
            server::linkage::connect_server($name)
        }
    }

}

sub load_requirements {

    if (defined( my $pkg = conf qw[class normal_package] )) {
        log2('Loading '.$pkg);
        $pkg =~ s/::/\//g;
        require "$pkg.pm"
    }

    if (conf qw[enabled sha]) {
        log2('Loading Digest::SHA');
        require Digest::SHA
    }

    if (conf qw[enabled md5]) {
        log2('Loading Digest::MD5');
        require Digest::SHA
    }

    if (conf qw[enabled resolve]) {
        log2('Loading res, Net::IP, Net::DNS');
        require res
    }

}

sub create_sockets {
    foreach my $addr (keys %{$utils::conf{listen}}) {
    foreach my $port (@{$utils::conf{listen}{$addr}->{port}}) {

        # create the socket and add it to the IO::Select object
        my $socket = IO::Socket::IP->new(
            LocalAddr => $addr,
            LocalPort => $port,
            Listen    => 1,
            ReuseAddr => 1,
            Proto     => 'tcp'
        ) or fatal("Couldn't listen on [$addr]:$port: $!");

        log2("Listening on [$addr]:$port");
        ${*$socket}{listen} = 1;
        push @sel, $socket;
    } }
    return 1
}

# add data to the outgoing buffer
sub sendpeer {
    my $peer = shift;
    push @{${*$peer}{outbuffer}}, @_
}

# register a block of code to the main loop
sub register_loop {
    my ($name, $code) = @_;
    if (ref $code ne 'CODE') {
        log2("attempted to register a loop that is not CODE");
        return
    }
    my $id = ++$utils::GV{LOOP}{ID};
    $utils::GV{LOOP}{$id} = {
        code => $code,
        name => $name
    };
    log2("registered loop $id: $name");
    return 1
}

# delete an existing loop
sub delete_loop {
    my $id = shift;
    if (exists $utils::GV{LOOP}{$id}) {
        log2("deleted loop $id ($utils::GV{LOOP}{$id}{name})");
        delete $utils::GV{LOOP}{$id};
        return 1
    }
    log2("attempted to delete loop $id which does not exist");
    return
}

# stop the ircd
sub terminate {

    log2("removing all connections for server shutdown");

    # delete all users/servers/other
    foreach my $connection (values %connection::connection) {
        $connection->done('shutting down');
    }

    log2("deleting PID file");

    # delete the PID file
    unlink 'etc/juno.pid' or fatal("Can't remove PID file");

    log2("shutting down");
    exit
}

# handle a HUP
sub signalhup {

    # find out what is wanted
    open my $hup, 'etc/HUP' or log2('can\'t open HUP file') and return;

    while (my $line = <$hup>) {
    given ((split /\s+/, $line)[0]) {
        when ('rehash') {
            log2("reloading server configuration file by request of HUP signal");
            utils::parse_config('etc/ircd.conf') or log2("configuration error");
            log2("finished rehashing");              
        }
        when ('terminate') {
            log2("terminating by request of HUP signal");
            terminate();
        }
        deafult { return }
    } }

    return 1
}

# handle warning
sub WARNING {
    log2(shift);
}
